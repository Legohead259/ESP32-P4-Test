{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ROSphoros","text":"<p>Bringing illumination - and topics - to the world of embedded electronics</p> <p>This is the documentation hub for ROSphoros - a proving playground for PlatformIO environment experimentation, Over the Air (OTA) updates, and micro-ROS on edge devices. ROSphoros investigates connecting multiple microcontrollers and a main ROS2 autonomy stack over a Local Area Network (LAN). The project taps directly into the strengths of ROS2's Data Distribution Service (DDS) architecture by using the micro-ROS library to deploy those capabilities natively to the microcontrollers. An agent running on the main ROS2 stack manages the connections to the microcontrollers and shares data between the different hardware nodes. This documentation records the \"Hello World\" initialization of these features as well as the initial Research and Development, Testing and Evaluation (RDTE) system architecture and methodology.</p> <p>Figure 1: The 10-inch rack serving as the RDTE testbed for the system.</p> <p>These docs will start from the beginning with setting up the programming and development environments and configuring the ROS2 installation and workspace. We will then walk through the process to configure Over the Air (OTA) programming, detail the underlying libraries in the codebase, and how to program and test a micro-ROS installation using a ROS2 agent. Building the hardware will be out of scope of this write-up, but the drawings, components, and 3D printed files will be provided.</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>For this project, we need to identify the scope of effort required and determine measurable metrics from which we can guide the project's development and determine its efficacy. To accomplish this, we will establish the Need, Goals, and Objectives (NGO). The Need is the driving reason why this project was undertaken. Goals define measures that are needed to accomplish the Need. Objectives define requirements that fulfill each Goal. The completion of all Goals and Objectives should therefore fulfill the Need. The NGO chart is shown below.</p> <p>Figure 2: The Needs, Goals, and Objectives chart for this project defining the scope of effort.</p>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>ESP32-P4-Test/\n\u251c\u2500\u2500 .git/\n\u2502   \u251c\u2500\u2500 COMMIT_EDITMSG\n\u2502   \u251c\u2500\u2500 FETCH_HEAD\n\u2502   \u251c\u2500\u2500 HEAD\n\u2502   \u251c\u2500\u2500 ORIG_HEAD\n\u2502   \u251c\u2500\u2500 branches/\n\u2502   \u251c\u2500\u2500 config\n\u2502   \u251c\u2500\u2500 description\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 index\n\u2502   \u251c\u2500\u2500 info/\n\u2502   \u251c\u2500\u2500 logs/\n\u2502   \u251c\u2500\u2500 objects/\n\u2502   \u251c\u2500\u2500 packed-refs\n\u2502   \u2514\u2500\u2500 refs/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 elegant_ota/\n\u2502   \u251c\u2500\u2500 ethernet_ota/\n\u2502   \u251c\u2500\u2500 ethernet_test/\n\u2502   \u251c\u2500\u2500 hello_world/\n\u2502   \u2514\u2500\u2500 micro_ros_test/\n\u251c\u2500\u2500 boards/\n\u2502   \u2514\u2500\u2500 esp32_p4.json\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 uros_colcon.meta\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u251c\u2500\u2500 mkdocs.yml\n\u2502   \u251c\u2500\u2500 site/\n\u2502   \u2514\u2500\u2500 source/\n\u251c\u2500\u2500 envs/\n\u2502   \u251c\u2500\u2500 common.ini\n\u2502   \u251c\u2500\u2500 controller_1.ini\n\u2502   \u251c\u2500\u2500 controller_2.ini\n\u2502   \u251c\u2500\u2500 controller_3.ini\n\u2502   \u251c\u2500\u2500 controller_4.ini\n\u2502   \u251c\u2500\u2500 ethernet_ota_followup.ini\n\u2502   \u251c\u2500\u2500 ethernet_ota_initial.ini\n\u2502   \u251c\u2500\u2500 ethernet_test.ini\n\u2502   \u2514\u2500\u2500 micro_ros_test.ini\n\u251c\u2500\u2500 include/\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 README\n\u2502   \u251c\u2500\u2500 controller/\n\u2502   \u251c\u2500\u2500 micro_ros_controller/\n\u2502   \u251c\u2500\u2500 micro_ros_pubsub/\n\u2502   \u2514\u2500\u2500 uros/\n\u251c\u2500\u2500 platformio.ini\n\u251c\u2500\u2500 src/\n\u251c\u2500\u2500 test/\n\u2514\u2500\u2500 variants/\n    \u2514\u2500\u2500 esp32_p4/\n</code></pre>"},{"location":"#resources","title":"Resources","text":""},{"location":"about/","title":"In saxa roboribusque cultis","text":""},{"location":"about/#tuum-saepe-sentiat","title":"Tuum saepe sentiat","text":"<p>Lorem markdownum et ferrum quam. Deus hac est inmanis isto, et arcus nomine visa est. Agendum et longo, conceptaque edere et quae liquidas, talia gerens omnibus vindicta nomine sitim tempora de incognita. Somnus seges Venus ligno virgo illa, pinu, nomen. Sola ore animos, malo fecit faciem Laomedonta quam mihique flumina, et relicto liceat ardescunt profanos.</p> <pre><code>lamp(monitorPersonal, online);\nbezelMoodleVolume(1, whois_scalable(access_hardware_nas));\nif (error_push.memoryRawVirtual.dpiRing(hfs_client_syntax + skyscraper,\n        link(-3, 45), 5)) {\n    domain_pebibyte_port -= tiffCropRuntime / gigaflops_apache;\n    midi = textIt + 884586 - 5;\n    binary_yobibyte_mirrored.languageRtfWildcard(filename_megahertz /\n            wikiFrameworkRuntime, mashup_refresh_camera, server);\n} else {\n    modifier_ribbon.menu = southbridge_thumbnail_day;\n    ios_expression_binary.tft(whois, 658481);\n    compilerRosettaMarket = 3;\n}\n</code></pre> <p>Epulas captum dextramque, et unda, voluit et cum, solis. Libidine Castore est clam ut latet socios pinu, artificem. Motus blanditus ardua venit territa illis percurrens absit quod quamvis pectore Tritoniacam et quod natus Egeriae!</p>"},{"location":"about/#ille-nam-aconita-manibus-nostra-retinentibus-pavet","title":"Ille nam aconita manibus nostra retinentibus pavet","text":"<p>Est Veneri orbes: cladis: paterer, cum essem huic maesto timeto, Sicaniam te canendi. Fulvas ipse ipse meae, avem per, medio imago vellem quam blandis et tamen muneris tectis eadem. Ignibus citaeque videri feruntur declivia digitos mille, est raptos admovet colligit diva frustraque mater sua. Cum nocebant praeter destrinxit Seriphon incomitata artesque exprimit exaestuat poteras intumuit Perseus olim alma coercuit funduntque pati; inque inmissa. Veneris certumque quam: longe aura hic haesit et fuit impelli neu, neci sparsos, vidit.</p> <ul> <li>Remige verba</li> <li>O nymphe Cyclopis ingeminat admissum tendere visis</li> <li>Cura legati</li> <li>Curvataque in venandi quam mortales bacchae altera</li> <li>Crescere cupiunt pectora</li> <li>Cadunt et fui huic statuo et comes</li> </ul> <p>Tamen et volucrem inbutam relinqui fluidos: comitem sine ubi illi. Est sui linigera maiores sol nullis oculisque at orbis; est versa ipsa amplexa generis, semihomines habenas surgit: colla. Fuit est tamen silvis ille lucem, putat petebatur dubiam, hic, habet. Dictis metu est, validos me dedit protinus non virginibus undis, testis sollicitae instructamque conscia ipsoque. Possit ille pectore, nocturnos de duro amore magistris parantes, at edidit.</p> <p>Sua quae cum, manibus di hostesque caput, cum deum diffugiunt illum venter amore! Reverti in respicit lilia, nec comes quondam. Maeoniaeque sinunt; puppes credulus vincere ad rapto spernitque totum. Populo fuit erat metu ausa Thebae; vultus descendere sed candida facta!</p>"},{"location":"getting-started/autonomy-computer-setup/","title":"Autonomoy Computer Software Setup","text":"<p>Let's get started making some software!</p>"},{"location":"getting-started/autonomy-computer-setup/#installation","title":"Installation","text":"<p>The software setup for the autonomy computer will assume that host operating system is Ubuntu 22.04.5 LTS and the required software has been installed according to their respective documents. The full list of software applications required and their installation procedures are listed below:</p> <ul> <li>ROS2 Humble</li> <li>Visual Studio Code</li> <li>PlatformIO IDE for VSCode</li> <li>Docker Engine</li> <li>micro-ROS (only do the \"Installing ROS2 and the micro-ROS build system\" and \"Creating the micro-ROS agent\" sections)</li> </ul> <p>With everything installed, we need to make a slight configuration change to Docker to make it easier to use. With a fresh installation, Docker requires a root user (sudo) to function. If your device policies allow it, follow the Docker documentation to manage Docker as a non-root user.</p>"},{"location":"getting-started/autonomy-computer-setup/#cloning-the-repository","title":"Cloning the Repository","text":"<p>With that completed, we can clone the latest project workspace to a project directory on the machine. <code>git clone https://github.com/Legohead259/ESP32-P4-Test</code> The project (v1.0.0-rc1) has the following directory structure:</p> <pre><code>ESP32-P4-Test/\n\u251c\u2500\u2500 .git/\n\u2502   \u251c\u2500\u2500 COMMIT_EDITMSG\n\u2502   \u251c\u2500\u2500 FETCH_HEAD\n\u2502   \u251c\u2500\u2500 HEAD\n\u2502   \u251c\u2500\u2500 ORIG_HEAD\n\u2502   \u251c\u2500\u2500 branches/\n\u2502   \u251c\u2500\u2500 config\n\u2502   \u251c\u2500\u2500 description\n\u2502   \u251c\u2500\u2500 hooks/\n\u2502   \u251c\u2500\u2500 index\n\u2502   \u251c\u2500\u2500 info/\n\u2502   \u251c\u2500\u2500 logs/\n\u2502   \u251c\u2500\u2500 objects/\n\u2502   \u251c\u2500\u2500 packed-refs\n\u2502   \u2514\u2500\u2500 refs/\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 apps/\n\u2502   \u251c\u2500\u2500 elegant_ota/\n\u2502   \u251c\u2500\u2500 ethernet_ota/\n\u2502   \u251c\u2500\u2500 ethernet_test/\n\u2502   \u251c\u2500\u2500 hello_world/\n\u2502   \u2514\u2500\u2500 micro_ros_test/\n\u251c\u2500\u2500 boards/\n\u2502   \u2514\u2500\u2500 esp32_p4.json\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 uros_colcon.meta\n\u251c\u2500\u2500 docs/\n\u2502   \u251c\u2500\u2500 main.py\n\u2502   \u251c\u2500\u2500 mkdocs.yml\n\u2502   \u251c\u2500\u2500 site/\n\u2502   \u2514\u2500\u2500 source/\n\u251c\u2500\u2500 envs/\n\u2502   \u251c\u2500\u2500 common.ini\n\u2502   \u251c\u2500\u2500 controller_1.ini\n\u2502   \u251c\u2500\u2500 controller_2.ini\n\u2502   \u251c\u2500\u2500 controller_3.ini\n\u2502   \u251c\u2500\u2500 controller_4.ini\n\u2502   \u251c\u2500\u2500 ethernet_ota_followup.ini\n\u2502   \u251c\u2500\u2500 ethernet_ota_initial.ini\n\u2502   \u251c\u2500\u2500 ethernet_test.ini\n\u2502   \u2514\u2500\u2500 micro_ros_test.ini\n\u251c\u2500\u2500 include/\n\u251c\u2500\u2500 lib/\n\u2502   \u251c\u2500\u2500 README\n\u2502   \u251c\u2500\u2500 controller/\n\u2502   \u251c\u2500\u2500 micro_ros_controller/\n\u2502   \u251c\u2500\u2500 micro_ros_pubsub/\n\u2502   \u2514\u2500\u2500 uros/\n\u251c\u2500\u2500 platformio.ini\n\u251c\u2500\u2500 src/\n\u251c\u2500\u2500 test/\n\u2514\u2500\u2500 variants/\n    \u2514\u2500\u2500 esp32_p4/\n</code></pre>"},{"location":"getting-started/autonomy-computer-setup/#platformio-environment-file-interactions","title":"PlatformIO Environment File Interactions","text":"<p>Breaking down this structure, we can start with the platformio.ini file with is the main configuration file for the PlatformIO project workspace. It imports the files located in the <code>env/</code> directory which in turn cross-reference each other and build the configurations for each controller programming environment. The interactions between the environmental files and the rest of the application code is documented in the chart below. Note that for brevity, only \"controller_1\" is shown in the chart. The interactions are the same for the other controllers. The blue boxes, \"OTA Initial\", \"OTA Followup\", and \"MicroROS Test\" denote the actual PlatformIO environments that are uploaded the microcontrollers. These will be explore more in-depth shortly.</p> <p>Figure 1: The interactions between the PlatformIO environmental variables and the relevant sections of the workspace.</p> <p>The green \"ESP32-P4 Base\" component leverages the Arduino framework's capability to define custom board variants for a project. This will allow us to define custom pin variables in the future depending on what is connected to the microcontroller. For the moment, we have to source the ESP32-P4 build framework from the PIOArduino fork of PlatformIO since official support has not been rolled out at time of writing. Within the \"Common\" configuration, we can also define environmental variables that will be shared by all the microcontrollers like the IP address domain. From the ESP32-P4 base, we can build out the \"Controller Base\" definition which will include all of the build flags like the IP domain, controller name, ROS domain ID. From the \"Controller Base\" definition, we can define an extended definition for \"Controller OTA\" that contains the information like the upload protocol, IP address, port, and login information to enable OTA programming.</p>"},{"location":"getting-started/hardware-overview/","title":"Hardware Overview","text":"<p>This project utilizes Commercial Off the Shelf (COTS) hardware to simplify development. This section will go over all of the hardware required and the system architecture used to connect everything together.</p>"},{"location":"getting-started/hardware-overview/#microcontroller","title":"Microcontroller","text":"<p>The ESP32-P4 is a high-performance System on Chip (SoC) variant of the popular ESP32 line of microcontrollers from Espressif. The SoC is powered by a dual-core RISC-V CPU featuring an AI accelerator, advanced memory management, and high-speed peripherals. The ESP32-P4 is specifically designed for high-performance edge computing as required by the overarching project and was chosen for its wealth of peripherals, ease of programming, and raw performance.</p> <p>The Waveshare ESP32-P4-NANO is a development board based on the ESP32-P4 SoC that breaks out some of the peripherals and provides a native 10/100 ethernet connection. This board comes with a special Power Over Ethernet (POE) expansion board that enables the board to communicate with and be powered by a 802.3af-compliant router or switch. The low Size, Weight, and Power (SWaP) specifications for this board make it ideal for a small RDTE testbench like can be provided by a 10-inch minirack.</p> <p>Figure 1: The Waveshare ESP32-P4-NANO development board. Courtesy of Waveshare</p>"},{"location":"getting-started/hardware-overview/#mini-rack","title":"Mini Rack","text":"<p>A miniature 10-inch server rack was explored for this project as the RDTE test bed because it is highly configurable, portable, and can keep wires tidy and organized. Research was conducted on Jeff Geerling's website, Project MINI RACK, to determine a suitable combination of hardware components to support the effort. Ultimately, a 4U DeskPi RackMate T0 was chosen because of its cost and availability.</p> <p>Figure 2: The RDTE testbed hardware enclosure. Courtesy of DeskPi</p>"},{"location":"getting-started/hardware-overview/#routerswitch","title":"Router/Switch","text":"<p>Eventually, this project will investigate using a router and Virtual Private Network (VPN) to establish connections from various data sources outside the LAN. This means that the RDTE testbed needs to support up to eight ethernet devices, POE, routing, firewalls, and VPN services within 2U of rack space. Project MINI RACK lists some switches that are 10-inch rack-compatible and of those, only one (at time of component selection) fulfilled those requirements: the MikroTik CRS112-8P-4S-IN with a 48V power supply.</p> <p>This unit provides a maximum of 1.4A@48V (450 mA per port) which is more than sufficient for the ESP32-P4. It also runs MikroTik RouterOS and is compatible with their entire suite of Software Defined Networking (SDN) equipment which will be useful for the project's future. The CRS112 also supports routing, firewalls, DHCP services, and VPN over IPSec which fulfills all the requirements while only being 1U tall.</p> <p>Figure 3: The CRS112-8P-4S-IN POE router and switch. Courtesy of MikroTik</p>"},{"location":"getting-started/hardware-overview/#rdte-testbed","title":"RDTE Testbed","text":"<p>The ESP32-P4 microcontrollers are connected to the switch using short lengths of CAT5E ethernet cable. Another ethernet cable is used to connect the switch to the autonomy computer. The overall rack layout with connections is shown below.</p> <p>Figure 4: The 4U rack layout for the RDTE testbed with ethernet connections shown in blue. CRS112 image courtesy of MikroTik</p>"},{"location":"getting-started/hardware-setup/","title":"Hardware Setup","text":"<p>The LAN for the RDTE testbed has a static IP domain and each device has a static IP address. The domain was chosen largely at random and configured according to the instructions and software provided by MikroTik for their RouterOS. Each device was confirmed to be connected using the IP device management features present on the CRS112. These features were also used to ensure power is being appropriately provided to each microcontroller through the Ethernet connection.</p> <p>The autonomy computer was then connected to the first microcontroller and the first set of firmware was uploaded to enable OTA functionality.</p>"},{"location":"getting-started/software-overview/","title":"Software Overview","text":"<p>This project utilizes existing libraries, open source software, and development frameworks where possible to simplify development. This section will go over all of the software frameworks used.</p>"},{"location":"getting-started/software-overview/#ros2","title":"ROS2","text":"<p>The core software is ROS2 which provides DDS capabilities and the underlying framework for all of the software nodes. The autonomy computer runs Ubuntu 22.04.5 and has ROS2 Humble Hawksbill installed on it according to the documentation provided by the Open Source Robotics Foundation (OSRF).</p> <p>Figure 1: ROS2 Humble Hawksbill Logo</p>"},{"location":"getting-started/software-overview/#micro-ros","title":"Micro-ROS","text":"<p>All of the hardware nodes (autonomy computer and four microcontrollers) are connected via LAN, so we could use a traditional REST API or TCP/UDP API to transfer data between the different nodes to accomplish tasks. However, micro-ROS provides a unique capability that allows microcontrollers to interact with a ROS2 stack via a transport layer. Micro-ROS runs on a variety of microcontrollers - including the ESP32 family, and allows seamless integration with a ROS2 stack through an agent node. Setting up the micro-ROS workspace on the autonomy computer will be covered in a later section.</p> <p>Figure 2: Micro-ROS Logo</p>"},{"location":"getting-started/software-overview/#ide","title":"IDE","text":"<p>In a future iteration of the project, the microcontrollers will be running different applications, so we need a way to manage multiple libraries, environmental variables, and source applications - ideally within the same programming workspace to minimize clutter and the need to have multiple windows open simultaneously. Visual Studio Code is a powerful IDE that has a wide-array of extensions and workspace management tools to enable our requirements. VS Code supports PlatformIO through an extension which allows us to manage different platforms, board specifications, frameworks, libraries, etc. within a single workspace.</p> <p>Using the platformio.ini file, we can create different programming environments that have a variety of variables we can change; this allows us to load different applications to different upload ports using different compilation variables - perfect for our use-case. Because of the project's complexity, we will not just be using the single platformio.ini file. A detailed breakdown of the environmental organizational structure will be provided in a later section.</p> VS Code PlatformIO"},{"location":"getting-started/software-overview/#docker","title":"Docker","text":"<p>For simplicity, we will containerize the final ROS2 workspace and launch file so that it can be quickly spun up and deployed like an application without the need for multiple different processes running on the host machine. Therefore, we will use Docker engine to create and manage the container for us.</p> <p>Figure 3: Docker Logo</p>"},{"location":"user-guide/","title":"Overview","text":"<p>Hardware and software used for this project</p>"}]}